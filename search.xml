<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>策略模式</title>
    <url>/2021/08/03/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Strategy Pattern defines a family of algorithms,<br>encapsulates each one, and makes them interchangeable.<br>Strategy lets the algorithm vary independently from<br>clients that use it.</p>
<span id="more"></span>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>设计一群会叫会游泳的鸭子，长相不同<br><img src="/images/114606130770.png"></p>
<p>让部分鸭子增加会飞的功能</p>
<h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>利用继承在父类中增加fly方法，对于自定义的鸭子行为进行重写方法<br><img src="/images/2937315149196.png"><br>缺点：</p>
<ul>
<li>在多个子类中会存在重复代码</li>
<li>不易在运行时改变鸭子行为</li>
<li>不易获得所有鸭子行为</li>
<li>改变父类容易影响到其他鸭子</li>
</ul>
<h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>将鸭子实现飞行和叫的接口<br><img src="/images/697503147063.png"><br>缺点：</p>
<ul>
<li>重复代码过多</li>
<li>难以维护修改你需要找到所有实现的类一个个修改</li>
<li>没有代码重用</li>
</ul>
<h1 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h1><p><img src="/images/5795704179898.png"></p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul>
<li>把不同的部分拿出来进行封装，后期修改扩张的时候就不会影响到其他部分</li>
<li>面向接口编程</li>
<li>多写组合而非继承</li>
</ul>
<p><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/08/03/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Observer Pattern defines a one-to-many<br>dependency between objects so that when one<br>object changes state, all of its dependents are<br>notified and updated automatically.</p>
<span id="more"></span>
<p><img src="/images/4811438157136.png"></p>
<p>类图<br><img src="/images/2708241177302.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>气象站实时获取温度、湿度、气压，编写一个应用可以同步显示<br>当前天气， 气候统计， 气象预测， 并发布一个api，其他开发者<br>也可以实时订阅气象站数据<br><img src="/images/2123752140843.png"></p>
<h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p><img src="/images/5772812169269.png"><br>缺点：</p>
<ul>
<li>面向具体实现编码而非接口</li>
<li>增加新的显示器都需要改变代码</li>
<li>不能在运行时增加新的显示器订阅者</li>
<li>没有将变化的部分封装起来</li>
</ul>
<h1 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h1><p><img src="/images/4327309179971.png"></p>
<h1 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h1><ul>
<li>努力在相互作用的对象之间进行松散耦合的设计</li>
</ul>
<p><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/2021/08/05/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Decorator Pattern attaches additional  responsibilities<br>to an object dynamically. Decorators provide a flexible<br>alternative to  subclassing for extending functionality</p>
<span id="more"></span>
<h1 id="装饰着类图"><a href="#装饰着类图" class="headerlink" title="装饰着类图"></a>装饰着类图</h1><p><img src="/images/832903100845.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>星巴克饮料类图如下图所示<br><img src="/images/2869517179271.png"><br>现需要对各个饮料增加调料steamed milk, soy, and mocha，计算价格。</p>
<h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>给每种调料的饮料编写一个类<br><img src="/images/3164940167138.png"></p>
<p>缺点</p>
<ul>
<li>组合情况过多需要产生n种类</li>
<li>若调料价格上涨，或增加新的调料后期很难维护</li>
</ul>
<h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>在父类中标记每种调料是否存在，cost方法中计算好调料价格以便子类调用。<br><img src="/images/4032754187304.png"><br><img src="/images/5988755179973.png"><br>缺点</p>
<ul>
<li>增加新的调料需要在父类中增加新的方法和修改cost方法</li>
<li>对于这些饮料，并不需要所有调料，设计冗余</li>
<li>若需要双份调料也无法该设计也无法满足要求</li>
</ul>
<h1 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h1><pre><code>代码对修改封闭，对扩展开放，此原则并不需要对每个部分都采用因为浪费时间，
且不必要增加代码复杂度，我们只需要把精力放在最有可能变化的部分
</code></pre>
<h1 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h1><p><img src="/images/3375335186528.png"></p>
<p><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2021/08/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式定义"><a href="#工厂模式定义" class="headerlink" title="工厂模式定义"></a>工厂模式定义</h1><p>The Factory Method Pattern defines an interface<br>for creating an object, but lets subclasses decide which<br>class to instantiate. Factory Method lets a class defer<br>instantiation to subclasses.</p>
<span id="more"></span>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>创建一个能生产不同pizza的类<br><img src="/images/1019703110846.png"></p>
<p>若此时你需要删除greekpizza增加clampizza和veggiepizza需要怎么做呢<br><img src="/images/3640108129272.png"><br>根据之前的设计原则变化的部分要从不变的部分独立开来，且该类违反了开放封闭原则，每次<br>修改订单都需要修改oderpizza的代码。</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>相同的部分为pizza的制作过程，变化的部分为new对象的过程，所以我们将创建对象的过程<br>封装起来，这就简单工厂模式<br><img src="/images/590608137139.png"><br><img src="/images/749512157305.png"></p>
<h2 id="简单工厂模式类图"><a href="#简单工厂模式类图" class="headerlink" title="简单工厂模式类图"></a>简单工厂模式类图</h2><p><img src="/images/896719149974.png"></p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>现纽约、芝加哥等地都想有自己的pizza店，但每个区域都想要不同口味的pizza<br>其中一种解法为我们给每个地区建各自的工厂类如下图代码所示<br><img src="/images/2710839156529.png"><br>另一种方法则为工厂模式</p>
<h2 id="工厂模式类图"><a href="#工厂模式类图" class="headerlink" title="工厂模式类图"></a>工厂模式类图</h2><p><img src="/images/2519658177767.png"><br><strong>工厂方法的本质是将创建对象的方法独立出来，让子类决定实例化哪一个对象<br>先建立一个抽象类，在之类中实现创建方法，这样就将父类中客户端的代码和<br>子类的创建对象方法解耦</strong><br><img src="/images/5688420180163.png"><br><strong>备注：传参类型用string并不是一个好的方法无法保证参数安全，可考虑用枚举类</strong><br><img src="/images/289910100847.png"></p>
<h1 id="抽象工厂模式定义"><a href="#抽象工厂模式定义" class="headerlink" title="抽象工厂模式定义"></a>抽象工厂模式定义</h1><p>The Abstract Factory Pattern provides an interface<br>for creating families of related or dependent objects<br>without specifying their concrete classes.</p>
<h1 id="抽象工厂类图"><a href="#抽象工厂类图" class="headerlink" title="抽象工厂类图"></a>抽象工厂类图</h1><p><img src="/images/4777433176510.png"></p>
<h1 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h1><p>现不同地区使用pizza的原料各不相同，请用抽象工厂表示<br><img src="/images/2411335198950.png"></p>
<h1 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h1><p>依赖反转原理，依赖抽象而不依赖具体类<br>依赖反转：高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口<br>以工厂模式为例pizzastore是高层次组件，pizza具体类为底层次组件两者都依赖于<br>同一个接口pizza<br><img src="/images/5495150185269.png"></p>
<h1 id="简单工厂、工厂模式，抽象工厂的区别"><a href="#简单工厂、工厂模式，抽象工厂的区别" class="headerlink" title="简单工厂、工厂模式，抽象工厂的区别"></a>简单工厂、工厂模式，抽象工厂的区别</h1><p><strong>相同点：</strong> 本质都是封装对象的创建行为，将代码从具体类型中解耦出来，让子类实例化时决定创建具体类</p>
<p>简单工厂是将创建对象方法封装成一个新类，和客户端代码是组合关系，工厂模式和客户端类是继承关系。<br>抽象工厂提供一个类来创建一个产品家族的抽象类型,<br>优点：可以把一群相关的产品集合起来创建。<br>缺点：如果新加入创建的产品，就必须要改变接口。</p>
<p><strong>使用条件</strong>：当你需要创建产品家族和想让制造的相关产品集合起来时，<br>你可以使用抽象工厂。当你需要创建一种类型的对象时，你可以选择使用工厂方法。<br><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/08/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Singleton Pattern ensures a class has only one<br>instance, and provides a global point of access to it.</p>
<span id="more"></span>
<h1 id="单例模式类图"><a href="#单例模式类图" class="headerlink" title="单例模式类图"></a>单例模式类图</h1><p><img src="/images/470037149273.png"></p>
<h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有化构造器，声明一个静态变量和静态方法。当调用getInstance时如果没有创建对象，则创建对象<br>否则直接返回单例对象</p>
<p>上图代码只适用于单线程，如果是多线程还是有可能创建多个对象，当多个线程同时运行到<br>if (uniqueInstance == null) 该行代码之后，线程1创建完对象之后，回到线程2执行，由于<br>之前判断过uniqueInstance为null所以这时候仍会创建对象</p>
<h1 id="懒汉式线程安全"><a href="#懒汉式线程安全" class="headerlink" title="懒汉式线程安全"></a>懒汉式线程安全</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在getInstance方法上加锁保证任何时候都不会有两个线程进入该方法<br><strong>优点</strong>：第一次调用才初始化，避免内存浪费。<br><strong>缺点</strong>：加锁虽然可以解决多线程问题，但是增加了不必要的开销，因为创建完对象之后，获取对象<br>也需要等待锁</p>
<h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：没有加锁，执行效率会提高。<br><strong>缺点</strong>：类加载时就初始化，浪费内存。</p>
<h1 id="双重判定"><a href="#双重判定" class="headerlink" title="双重判定"></a>双重判定</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们会检查实例是否被创建，如果没有我们再加锁，若已创建，则直接返回对象，不需要等锁<br>在多线程环境中，被volatile修饰的变量，在某个线程中被修改，在各个线程中立即可见<br><font color=red>此方法在jdk1.4(含)之前无效，切勿使用</font></p>
<h1 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>一般用在配置或线程池连接池上，供全局访问<br><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式与外观模式</title>
    <url>/2021/08/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="适配器模式定义"><a href="#适配器模式定义" class="headerlink" title="适配器模式定义"></a>适配器模式定义</h1><p>The Adapter Pattern converts the interface of a class<br>into another interface the clients expect. Adapter lets<br>classes work together that couldn’t otherwise because of<br>incompatible interfaces.</p>
<span id="more"></span>

<h1 id="适配器类图"><a href="#适配器类图" class="headerlink" title="适配器类图"></a>适配器类图</h1><p><img src="/images/1449918182284.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>想象一下你有一个已经存在的系统你需要更换新的vendor class的库，但是新的vendor class的<br>库又不同于之前的接口如下图所示<br><img src="/images/5546339200164.png"></p>
<p>我们不可以修改已有的系统代码，也不可以修改vendor的代码，这时我们可以写一个<br>新类来使vendor class适配我们已有的代码接口。<br><img src="/images/3029544197768.png"></p>
<p>比如我们拿鸭子举例，我们有个鸭子接口如下代码所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是个鸭子的实现类MallardDuck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另有一个火鸡的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>火鸡的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gobble gobble&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am flying a short distance&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们发现鸭子数量不够，需要用火鸡代替，显然我们不能直接用火鸡因为<br>他们有不同的接口，所以让我们来写一个适配对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Turkey turkey;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还需要个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MallardDuck duck = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">    WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">    testDuck(duck);</span><br><span class="line">    testDuck(<span class="keyword">new</span> TurkeyAdapter(turkey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDuck</span><span class="params">(Duck duck)</span> </span>&#123;</span><br><span class="line">    duck.quack();</span><br><span class="line">    duck.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将我们的代码带入适配器模式的类图中去<br><img src="/images/1317203110850.png"></p>
<h1 id="外观模式定义"><a href="#外观模式定义" class="headerlink" title="外观模式定义"></a>外观模式定义</h1><p>The Facade Pattern provides a unified interface to a<br>set of interfaces in a subsytem. Facade defines a higher-level<br>interface that makes the subsystem easier to use.</p>
<h1 id="外观模式类图"><a href="#外观模式类图" class="headerlink" title="外观模式类图"></a>外观模式类图</h1><p><img src="/images/761949179276.png"></p>
<h1 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h1><p>现有以下设备组建成家庭影院<br><img src="/images/2234253167143.png"><br>看电影前需要做以下动作<br><img src="/images/5430254187309.png"><br>对应以下代码<br><img src="/images/5665856179978.png"><br>通过外观模式可大大简化繁琐的操作步骤，外观类将影院的组件视作子系统，把看电影的动作都封装<br>成方法，简化客户端代码的使用且让客户端和系统组件解耦分离<br><img src="/images/5864801186533.png"><br>开关电影代码如下图所示<br><img src="/images/3542520182287.png"></p>
<h1 id="装饰者模式、适配器模式、外观模式区别"><a href="#装饰者模式、适配器模式、外观模式区别" class="headerlink" title="装饰者模式、适配器模式、外观模式区别"></a>装饰者模式、适配器模式、外观模式区别</h1><p>装饰者模式：不改变接口，增加功能<br>适配器模式：将一个接口转换成另一个接口<br>外观模式： 让多个负责的接口可以被客户端简单使用</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
