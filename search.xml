<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>策略模式</title>
    <url>/2021/08/03/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Strategy Pattern defines a family of algorithms,<br>encapsulates each one, and makes them interchangeable.<br>Strategy lets the algorithm vary independently from<br>clients that use it.</p>
<span id="more"></span>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>设计一群会叫会游泳的鸭子，长相不同<br><img src="/images/114606130770.png"></p>
<p>让部分鸭子增加会飞的功能</p>
<h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>利用继承在父类中增加fly方法，对于自定义的鸭子行为进行重写方法<br><img src="/images/2937315149196.png"><br>缺点：</p>
<ul>
<li>在多个子类中会存在重复代码</li>
<li>不易在运行时改变鸭子行为</li>
<li>不易获得所有鸭子行为</li>
<li>改变父类容易影响到其他鸭子</li>
</ul>
<h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>将鸭子实现飞行和叫的接口<br><img src="/images/697503147063.png"><br>缺点：</p>
<ul>
<li>重复代码过多</li>
<li>难以维护修改你需要找到所有实现的类一个个修改</li>
<li>没有代码重用</li>
</ul>
<h1 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h1><p><img src="/images/5795704179898.png"></p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul>
<li>把不同的部分拿出来进行封装，后期修改扩张的时候就不会影响到其他部分</li>
<li>面向接口编程</li>
<li>多写组合而非继承</li>
</ul>
<p><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/08/03/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Observer Pattern defines a one-to-many<br>dependency between objects so that when one<br>object changes state, all of its dependents are<br>notified and updated automatically.</p>
<span id="more"></span>
<p><img src="/images/4811438157136.png"></p>
<p>类图<br><img src="/images/2708241177302.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>气象站实时获取温度、湿度、气压，编写一个应用可以同步显示<br>当前天气， 气候统计， 气象预测， 并发布一个api，其他开发者<br>也可以实时订阅气象站数据<br><img src="/images/2123752140843.png"></p>
<h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p><img src="/images/5772812169269.png"><br>缺点：</p>
<ul>
<li>面向具体实现编码而非接口</li>
<li>增加新的显示器都需要改变代码</li>
<li>不能在运行时增加新的显示器订阅者</li>
<li>没有将变化的部分封装起来</li>
</ul>
<h1 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h1><p><img src="/images/4327309179971.png"></p>
<h1 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h1><ul>
<li>努力在相互作用的对象之间进行松散耦合的设计</li>
</ul>
<p><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/2021/08/05/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Decorator Pattern attaches additional  responsibilities<br>to an object dynamically. Decorators provide a flexible<br>alternative to  subclassing for extending functionality</p>
<span id="more"></span>
<h1 id="装饰着类图"><a href="#装饰着类图" class="headerlink" title="装饰着类图"></a>装饰着类图</h1><p><img src="/images/832903100845.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>星巴克饮料类图如下图所示<br><img src="/images/2869517179271.png"><br>现需要对各个饮料增加调料steamed milk, soy, and mocha，计算价格。</p>
<h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>给每种调料的饮料编写一个类<br><img src="/images/3164940167138.png"></p>
<p>缺点</p>
<ul>
<li>组合情况过多需要产生n种类</li>
<li>若调料价格上涨，或增加新的调料后期很难维护</li>
</ul>
<h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>在父类中标记每种调料是否存在，cost方法中计算好调料价格以便子类调用。<br><img src="/images/4032754187304.png"><br><img src="/images/5988755179973.png"><br>缺点</p>
<ul>
<li>增加新的调料需要在父类中增加新的方法和修改cost方法</li>
<li>对于这些饮料，并不需要所有调料，设计冗余</li>
<li>若需要双份调料也无法该设计也无法满足要求</li>
</ul>
<h1 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h1><pre><code>代码对修改封闭，对扩展开放，此原则并不需要对每个部分都采用因为浪费时间，
且不必要增加代码复杂度，我们只需要把精力放在最有可能变化的部分
</code></pre>
<h1 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h1><p><img src="/images/3375335186528.png"></p>
<p><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2021/08/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式定义"><a href="#工厂模式定义" class="headerlink" title="工厂模式定义"></a>工厂模式定义</h1><p>The Factory Method Pattern defines an interface<br>for creating an object, but lets subclasses decide which<br>class to instantiate. Factory Method lets a class defer<br>instantiation to subclasses.</p>
<span id="more"></span>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>创建一个能生产不同pizza的类<br><img src="/images/1019703110846.png"></p>
<p>若此时你需要删除greekpizza增加clampizza和veggiepizza需要怎么做呢<br><img src="/images/3640108129272.png"><br>根据之前的设计原则变化的部分要从不变的部分独立开来，且该类违反了开放封闭原则，每次<br>修改订单都需要修改oderpizza的代码。</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>相同的部分为pizza的制作过程，变化的部分为new对象的过程，所以我们将创建对象的过程<br>封装起来，这就简单工厂模式<br><img src="/images/590608137139.png"><br><img src="/images/749512157305.png"></p>
<h2 id="简单工厂模式类图"><a href="#简单工厂模式类图" class="headerlink" title="简单工厂模式类图"></a>简单工厂模式类图</h2><p><img src="/images/896719149974.png"></p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>现纽约、芝加哥等地都想有自己的pizza店，但每个区域都想要不同口味的pizza<br>其中一种解法为我们给每个地区建各自的工厂类如下图代码所示<br><img src="/images/2710839156529.png"><br>另一种方法则为工厂模式</p>
<h2 id="工厂模式类图"><a href="#工厂模式类图" class="headerlink" title="工厂模式类图"></a>工厂模式类图</h2><p><img src="/images/2519658177767.png"><br><strong>工厂方法的本质是将创建对象的方法独立出来，让子类决定实例化哪一个对象<br>先建立一个抽象类，在之类中实现创建方法，这样就将父类中客户端的代码和<br>子类的创建对象方法解耦</strong><br><img src="/images/5688420180163.png"><br><strong>备注：传参类型用string并不是一个好的方法无法保证参数安全，可考虑用枚举类</strong><br><img src="/images/289910100847.png"></p>
<h1 id="抽象工厂模式定义"><a href="#抽象工厂模式定义" class="headerlink" title="抽象工厂模式定义"></a>抽象工厂模式定义</h1><p>The Abstract Factory Pattern provides an interface<br>for creating families of related or dependent objects<br>without specifying their concrete classes.</p>
<h1 id="抽象工厂类图"><a href="#抽象工厂类图" class="headerlink" title="抽象工厂类图"></a>抽象工厂类图</h1><p><img src="/images/4777433176510.png"></p>
<h1 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h1><p>现不同地区使用pizza的原料各不相同，请用抽象工厂表示<br><img src="/images/2411335198950.png"></p>
<h1 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h1><p>依赖反转原理，依赖抽象而不依赖具体类<br>依赖反转：高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口<br>以工厂模式为例pizzastore是高层次组件，pizza具体类为底层次组件两者都依赖于<br>同一个接口pizza<br><img src="/images/5495150185269.png"></p>
<h1 id="简单工厂、工厂模式，抽象工厂的区别"><a href="#简单工厂、工厂模式，抽象工厂的区别" class="headerlink" title="简单工厂、工厂模式，抽象工厂的区别"></a>简单工厂、工厂模式，抽象工厂的区别</h1><p><strong>相同点：</strong> 本质都是封装对象的创建行为，将代码从具体类型中解耦出来，让子类实例化时决定创建具体类</p>
<p>简单工厂是将创建对象方法封装成一个新类，和客户端代码是组合关系，工厂模式和客户端类是继承关系。<br>抽象工厂提供一个类来创建一个产品家族的抽象类型,<br>优点：可以把一群相关的产品集合起来创建。<br>缺点：如果新加入创建的产品，就必须要改变接口。</p>
<p><strong>使用条件</strong>：当你需要创建产品家族和想让制造的相关产品集合起来时，<br>你可以使用抽象工厂。当你需要创建一种类型的对象时，你可以选择使用工厂方法。<br><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/08/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Singleton Pattern ensures a class has only one<br>instance, and provides a global point of access to it.</p>
<span id="more"></span>
<h1 id="单例模式类图"><a href="#单例模式类图" class="headerlink" title="单例模式类图"></a>单例模式类图</h1><p><img src="/images/470037149273.png"></p>
<h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有化构造器，声明一个静态变量和静态方法。当调用getInstance时如果没有创建对象，则创建对象<br>否则直接返回单例对象</p>
<p>上图代码只适用于单线程，如果是多线程还是有可能创建多个对象，当多个线程同时运行到<br>if (uniqueInstance == null) 该行代码之后，线程1创建完对象之后，回到线程2执行，由于<br>之前判断过uniqueInstance为null所以这时候仍会创建对象</p>
<h1 id="懒汉式线程安全"><a href="#懒汉式线程安全" class="headerlink" title="懒汉式线程安全"></a>懒汉式线程安全</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在getInstance方法上加锁保证任何时候都不会有两个线程进入该方法<br><strong>优点</strong>：第一次调用才初始化，避免内存浪费。<br><strong>缺点</strong>：加锁虽然可以解决多线程问题，但是增加了不必要的开销，因为创建完对象之后，获取对象<br>也需要等待锁</p>
<h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：没有加锁，执行效率会提高。<br><strong>缺点</strong>：类加载时就初始化，浪费内存。</p>
<h1 id="双重判定"><a href="#双重判定" class="headerlink" title="双重判定"></a>双重判定</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们会检查实例是否被创建，如果没有我们再加锁，若已创建，则直接返回对象，不需要等锁<br>在多线程环境中，被volatile修饰的变量，在某个线程中被修改，在各个线程中立即可见<br><font color=red>此方法在jdk1.4(含)之前无效，切勿使用</font></p>
<h1 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>一般用在配置或线程池连接池上，供全局访问<br><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式与外观模式</title>
    <url>/2021/08/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="适配器模式定义"><a href="#适配器模式定义" class="headerlink" title="适配器模式定义"></a>适配器模式定义</h1><p>The Adapter Pattern converts the interface of a class<br>into another interface the clients expect. Adapter lets<br>classes work together that couldn’t otherwise because of<br>incompatible interfaces.</p>
<span id="more"></span>

<h1 id="适配器类图"><a href="#适配器类图" class="headerlink" title="适配器类图"></a>适配器类图</h1><p><img src="/images/1449918182284.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>想象一下你有一个已经存在的系统你需要更换新的vendor class的库，但是新的vendor class的<br>库又不同于之前的接口如下图所示<br><img src="/images/5546339200164.png"></p>
<p>我们不可以修改已有的系统代码，也不可以修改vendor的代码，这时我们可以写一个<br>新类来使vendor class适配我们已有的代码接口。<br><img src="/images/3029544197768.png"></p>
<p>比如我们拿鸭子举例，我们有个鸭子接口如下代码所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是个鸭子的实现类MallardDuck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另有一个火鸡的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>火鸡的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Gobble gobble&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am flying a short distance&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们发现鸭子数量不够，需要用火鸡代替，显然我们不能直接用火鸡因为<br>他们有不同的接口，所以让我们来写一个适配对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Turkey turkey;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还需要个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MallardDuck duck = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">    WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">    testDuck(duck);</span><br><span class="line">    testDuck(<span class="keyword">new</span> TurkeyAdapter(turkey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDuck</span><span class="params">(Duck duck)</span> </span>&#123;</span><br><span class="line">    duck.quack();</span><br><span class="line">    duck.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将我们的代码带入适配器模式的类图中去<br><img src="/images/1317203110850.png"></p>
<h1 id="外观模式定义"><a href="#外观模式定义" class="headerlink" title="外观模式定义"></a>外观模式定义</h1><p>The Facade Pattern provides a unified interface to a<br>set of interfaces in a subsytem. Facade defines a higher-level<br>interface that makes the subsystem easier to use.</p>
<h1 id="外观模式类图"><a href="#外观模式类图" class="headerlink" title="外观模式类图"></a>外观模式类图</h1><p><img src="/images/761949179276.png"></p>
<h1 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h1><p>现有以下设备组建成家庭影院<br><img src="/images/2234253167143.png"><br>看电影前需要做以下动作<br><img src="/images/5430254187309.png"><br>对应以下代码<br><img src="/images/5665856179978.png"><br>通过外观模式可大大简化繁琐的操作步骤，外观类将影院的组件视作子系统，把看电影的动作都封装<br>成方法，简化客户端代码的使用且让客户端和系统组件解耦分离<br><img src="/images/5864801186533.png"><br>开关电影代码如下图所示<br><img src="/images/3542520182287.png"></p>
<h1 id="装饰者模式、适配器模式、外观模式区别"><a href="#装饰者模式、适配器模式、外观模式区别" class="headerlink" title="装饰者模式、适配器模式、外观模式区别"></a>装饰者模式、适配器模式、外观模式区别</h1><p>装饰者模式：不改变接口，增加功能<br>适配器模式：将一个接口转换成另一个接口<br>外观模式： 让多个负责的接口可以被客户端简单使用</p>
<p><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2021/08/11/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The State Pattern allows an object to alter its behavior<br>when its internal state changes. The object will appear to<br>change its class</p>
<span id="more"></span>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/5405208150851.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p><img src="/images/1530112169277.png"><br>现有状态机如上图所示，糖果机初始状态为没有硬币状态，<br>插入硬币后切换到有硬币状态，转动转轴进入糖果售卖状态<br>分发后根据糖果的数量切换至售空状态或者无币状态请用java编写出代码</p>
<h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><ol>
<li><p>首先，收集所有糖果机的所有状态<br>无币、有币、售卖中、售空</p>
</li>
<li><p>创建一个变量来保存当前糖果机的状态，为每一个状态定义一个值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> HAS_QUARTER = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> NO_QUARTER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> SOLD = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> SOLD_OUT = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> state  = SOLD_OUT;</span><br></pre></td></tr></table></figure></li>
<li><p>收集出在该系统中所有可能发生的行为<br>插币、退币、分发糖果、转动转轴</p>
</li>
<li><p>现在我创建一个状态机的类， 对于每一个动作，<br>我们要创建一个方法根据条件决定做响应，我们可以写一个像下面的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == HAS_QUARTER) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;you cant insert a quarter, the machine is sold out&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD_OUT) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;you cant insert a quarter, the machine is sold out&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;please wait, we are already giving you a gumball&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == NO_QUARTER) &#123;</span><br><span class="line">        state = HAS_QUARTER;</span><br><span class="line">        System.out.println(<span class="string">&quot;you inserted a quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：余下代码可在文章尾部找到连接<br>缺点：</p>
</li>
</ol>
<ul>
<li>代码违反开放封闭原则</li>
<li>这个设计甚至不能算面向对象</li>
<li>状态机的转换不明显都埋在一堆条件语句当中</li>
<li>没有分装变化的部分</li>
<li>后期增加有可能导致bug</li>
</ul>
<h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>通过状态模式实现如下图所示<br><img src="/images/134232177144.png"><br><img src="/images/2538648090852.png"></p>
<p><img src="/images/2175751109278.png"><br>一般来说，当状态转变是固定，状态切换过程放在context中更合适，<br>然而当转换是动态的，（例如有币状态依赖于币的个数切换到无币状<br>态或者售空状态）默认是放在状态类里面，这里我们通过context<br>提供get和set状态的方法来减少在状态类中硬编码<br><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2021/08/12/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Command Pattern encapsulates a request as an<br>object, thereby letting you parameterize other objects<br>with different requests, queue or log requests, and support<br>undoable operations.</p>
<span id="more"></span>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/4665238137145.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p><img src="/images/1875404170852.png"><br>做一个所有家电的开关，并支持撤销操作，现我们有以下家电<br><img src="/images/3106408189278.png"></p>
<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>首先我们来看个餐厅吃饭的例子，其中蕴含了命令模式<br><img src="/images/5867747109279.png"><br>顾客（客户端）创建订单，订单是一个接口只包含了一个orderup的方法和<br>厨师的引用，服务员不需要知道订单的内容那个初始做菜，她只需要将菜单<br>传递到前台，调用orderup即可，厨师只负责做饭<br><img src="/images/1548803107146.png"><br>顾客为client，订单为command，invoker为服务员，orderup 为execute,<br>厨师为receiver。takeorder为setCommand，此图恰好就命令模式的类图</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>按下列类图编写代码<br><img src="/images/3474517167312.png"><br>Commd接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Receiver具体的家电</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lightOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;light is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lightOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;light is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Command实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.lightOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.lightOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remoteControl （invoker）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line">    Command[] onCommand = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">    Command[] offCommand = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">    Command lastCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : onCommand) &#123;</span><br><span class="line">            command = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Command command : offCommand) &#123;</span><br><span class="line">            command = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> slot, Command onCommand, Command offCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onCommand[slot] = onCommand;</span><br><span class="line">        <span class="keyword">this</span>.offCommand[slot] = offCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>&#123;</span><br><span class="line">        onCommand[slot].execute();</span><br><span class="line">        lastCommand = onCommand[slot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>&#123;</span><br><span class="line">        offCommand[slot].execute();</span><br><span class="line">        lastCommand = offCommand[slot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lastCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remoteLoader (client) 创建command的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fan fan = <span class="keyword">new</span> Fan();</span><br><span class="line">        Light light = <span class="keyword">new</span> Light();</span><br><span class="line">        FanHighCommand fanHighCommand = <span class="keyword">new</span> FanHighCommand(fan);</span><br><span class="line">        FanLowCommand fanLowCommand = <span class="keyword">new</span> FanLowCommand(fan);</span><br><span class="line">        LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">        LightOffCommand lightOffCommand = <span class="keyword">new</span> LightOffCommand(light);</span><br><span class="line">        RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">        remoteControl.setCommand(<span class="number">0</span>, fanHighCommand, fanLowCommand);</span><br><span class="line">        remoteControl.setCommand(<span class="number">1</span>, lightOnCommand, lightOffCommand);</span><br><span class="line"></span><br><span class="line">        remoteControl.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        remoteControl.onButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">        remoteControl.undo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若此时我们需要一个智能开关，按动时候风扇低速，同时电灯打开<br>我们可以用宏命令将一堆命令封装同时继承Command接口来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacrosCommannd</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    Command[] commands;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommands</span><span class="params">(Command ... commands)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commands = commands;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            command.undo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MacrosCommannd macrosCommand = <span class="keyword">new</span> MacrosCommannd();</span><br><span class="line">        macrosCommand.setCommands(fanLowCommand, lightOnCommand);</span><br><span class="line"></span><br><span class="line">        MacrosCommannd macrosCommand1 = <span class="keyword">new</span> MacrosCommannd();</span><br><span class="line">        macrosCommand1.setCommands(fanHighCommand, lightOffCommand);</span><br><span class="line">        remoteControl.setCommand(<span class="number">2</span>,macrosCommand, macrosCommand1);</span><br><span class="line">        remoteControl.onButtonWasPushed(<span class="number">2</span>);</span><br><span class="line">        remoteControl.offButtonWasPushed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>客户端类产生Command 另一边多个线程执行接受到的Command<br>例如调度器、线程池</p>
<p><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板模式</title>
    <url>/2021/08/13/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>The Template Method Pattern defines the skeleton<br>of an algorithm in a method, deferring some steps to<br>subclasses. Template Method lets subclasses redefine<br>certain steps of an algorithm without changing the<br>algorithm’s structure.</p>
<span id="more"></span>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/3194533100854.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>使用模板模式编写coffee和茶叶的烹饪过程<br><img src="/images/2416857119280.png"><br><img src="/images/3266200117147.png"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><img src="/images/2133703137313.png"><br>上图分别是coffee和tea的制作过程两者一三步骤完全相同，只有二四是不同的<br>但是极其相似，我们可以抽象程以下结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> boilWater();</span><br><span class="line"> brew();</span><br><span class="line"> pourInCup();</span><br><span class="line"> addCondiments();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>饮品的抽象类<br><img src="/images/4051812129982.png"><br>prpareRecipe()定义为final是因为我们不想我们的子类重写它<br>改变模板。最后我们需要coffee和tea类，他们现在只依赖父类<br>处理烹饪饮品，他们只需要重写brew和addCondiments方法<br><img src="/images/2332917126537.png"><br>我们已经基本实现了模板模式让我们再回看一下父类的“模板方法”<br><img src="/images/5086120122291.png"><br>模板方法定义了算法步骤并允许子类提供一步或更多步的实现<br><img src="/images/5951410167775.png"><br>hook是一个声明再抽象类中的方法， 但是只给空实现，这样子类可以<br>在不同点挂钩子。比如我们可以实现一个顾客是否想要加调料的钩子<br><img src="/images/3226018165277.png"><br>子类可以重写钩子的方法<br><img src="/images/4203219146518.png"></p>
<h1 id="模板模式、策略模式、工厂模式区别"><a href="#模板模式、策略模式、工厂模式区别" class="headerlink" title="模板模式、策略模式、工厂模式区别"></a>模板模式、策略模式、工厂模式区别</h1><p>模板模式：让子类决定怎样实现算法的步骤<br>策略模式：封装可转换的行为接口，用委派方式决定那个行为被使用<br>工厂模式：子类决定哪一个具体类被创建<br><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2021/08/18/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>访问者模式是一种将算法与对象结构分离的软件设计模式。这种模式的工作方法如下：假设拥有一个由许多对象构成的对象结构，这些对象的类都拥有一个accept方法用来接受访问者对象；访问者是一个接口，它拥有一个visit方法，这个方法对访问到的对象结构中不同类型的元素做出不同的反应；在对象结构的一次访问过程中，遍历整个对象结构，对每个元素都实施accept方法，在每个元素的accept方法中回调访问者的visit方法，从而使访问者得以处理对象结构的每个元素；可以针对对象结构设计不同的具体访问者类来完成不同的操作。</p>
<span id="more"></span>

<h1 id="访问者模式类图"><a href="#访问者模式类图" class="headerlink" title="访问者模式类图"></a>访问者模式类图</h1><p><img src="/images/2472853130859.png"></p>
<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>假设某旅游爱好者决定在假期去北京、上海和深圳旅游，在每个城市都会进行一些不同的活动，需要通过访问者模式来实现。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>针对不同城市抽象出一个City接口。每个城市都通过accept方法接受访问者，其中Visitor表示访问人员的口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，创建具体的城市实体类，包括上述2个城市。每个城市的accept实现完全相同，调用访问者接口中实现的visit方法进行对应的活动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beijing</span> <span class="keyword">implements</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shanghai</span> <span class="keyword">implements</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;shanghai&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上述2个城市整合在旅游计划中。此外，用MutiCity类实现City的接口，在accept中对初始化构造的城市列表依次进行访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiCity</span> <span class="keyword">implements</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    City[] cities = &#123;<span class="keyword">new</span> Shanghai(), <span class="keyword">new</span> Beijing()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (City city : cities) &#123;</span><br><span class="line">            city.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，定义访问者Visitor接口。需要注意，在该接口中包含访问所有城市的visit方法，分别代表该访问者在不同城市的具体活动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Beijing beijing)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Shanghai shanghai)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设旅行者是一个人出行，这里实现一个SingleVisitor接口，代表该旅行者在不同城市所进行的活动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Beijing bejing)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I came to &quot;</span> + bejing.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Shanghai shanghai)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I came to &quot;</span> + shanghai.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，通过一个main类来执行整个流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MultiCity cities = <span class="keyword">new</span> MultiCity();</span><br><span class="line">    SingleVisitor singleVisitor = <span class="keyword">new</span> SingleVisitor();</span><br><span class="line">    cities.accept(singleVisitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>spark sql语法书解析</p>
<p><font color=red>备注</font>：<a href="https://github.com/zhxiaoping/designpattern">代码地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>spark内存超过限制</title>
    <url>/2021/08/30/spark%E5%86%85%E5%AD%98%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>Spark Issue: Container Killed by Yarn for Exceeding Memory Limits</p>
<span id="more"></span>
<h1 id="Symptoms"><a href="#Symptoms" class="headerlink" title="Symptoms"></a>Symptoms</h1><h2 id="Symptom-1"><a href="#Symptom-1" class="headerlink" title="Symptom 1"></a>Symptom 1</h2><p>Container killed by YARN for exceeding memory limits.<br>22.0 GB of 19 GB physical memory used. Consider boosting spark.yarn.executor.memoryOverhead or disabling yarn.nodemanager.vmem-check-enabled because of YARN-4714.</p>
<h2 id="Symptom-2"><a href="#Symptom-2" class="headerlink" title="Symptom 2"></a>Symptom 2</h2><p>Job aborted due to stage failure: Task 110 in stage 68.0 failed 1 times, most recent failure: Lost task 110.0 in stage 68.0: ExecutorLostFailure (executor 35 exited caused by one of the running tasks) Reason: Container killed by YARN for exceeding memory limits. 40.6 GB of 40 GB physical memory used. Consider boosting spark.yarn.executor.memoryOverhead.</p>
<h2 id="Symptom-3"><a href="#Symptom-3" class="headerlink" title="Symptom 3"></a>Symptom 3</h2><p>16/04/22 04:27:18 WARN yarn.YarnAllocator: Container marked as failed: container_1459803563374_223497_02_000067 on host. Exit status: 143. Diagnostics: Container [pid=30502,containerID=container_1459803563374_223497_02_000067] is running beyond physical memory limits. Current usage: 13.8 GB of 13.8 GB physical memory used; 14.6 GB of 28.9 GB virtual memory used. Killing container. Dump of the process-tree for container_1459803563374_223497_02_000067 : - PID PPID PGRPID SESSID CMD_NAME USER_MODE_TIME(MILLIS) SYSTEM_TIME(MILLIS) VMEM_USAGE(BYTES) RSSMEM_USAGE(PAGES) FULL_CMD_LINE - 30502 18022 30502 30502 (bash) 0 0 22773760 347 /bin/bash -c LD_LIBRARY_PATH=/apache/hadoop/lib/native:/apache/hadoop/lib/native/Linux-amd64-64: /usr/java/latest/bin/java -server -XX:OnOutOfMemoryError=’kill %p’ … container_1459803563374_223497_02_000067/stderr … Container killed on request. Exit code is 143 Container exited with a non-zero exit code 143</p>
<h1 id="Possible-Causes"><a href="#Possible-Causes" class="headerlink" title="Possible Causes"></a>Possible Causes</h1><ul>
<li><p>Spark on Yarn and virtual memory error and Container killed by YARN for exceeding memory limits have good discussions on solutions to fix the issue including some low-level explanation of the issue.</p>
</li>
<li><p>A bug (YARN-4714) in YARN.</p>
</li>
<li><p>Too much usage of off-heap memory. Spark Tungsten leverages off-heap memory a lot to boost performance. Some Java operations (especially IO related) also levarages off-heap memory. Usage of off-heap memory in Spark 2 (this has been changed in Spark 3) is control by spark.yarn.executor.memoryOverhead. Generally speaking, it is hard to control the usage of off-heap memory unless the corresponding Java operations provide such options. The JVM option MaxDirectMemorySize specifies the maximum total size of java.nio (New I/O package) direct buffer allocations (off-heap memory), which is used with network data transfer and serialization activity.</p>
</li>
<li><p>data skew (e.g., big data table but not partitioned)</p>
</li>
<li><p>Some tables in joins are too large.</p>
</li>
</ul>
<h1 id="Possible-Solutions"><a href="#Possible-Solutions" class="headerlink" title="Possible Solutions"></a>Possible Solutions</h1><ul>
<li><p>Increase memory overhead. For example, the below configuration set memory overhead to 8G.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--conf spark.yarn.executor.memoryOverhead=8G</span><br></pre></td></tr></table></figure></li>
<li><p>Reducing the number of executor cores (which helps reducing memory consumption). For example, change –execuor-cores=4 to –execuor-cores=2.</p>
</li>
<li><p>Increase the number of partitions (which makes each task smaller and helps reducing memory consumption).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--conf spark.sql.shuffle.partitions=2000</span><br></pre></td></tr></table></figure></li>
<li><p>Configure the JVM option MaxDirectMemorySize if your Spark application involves reading Parquet files and/or encoding/decoding BASE64 string, etc.<br>By default, MaxDirectMemorySize is close to the size of heap memory size. So, if MaxDirectoryMemorySize is not set, Spark containers might use too much off-heap memory.Maximum recommended memoryOverhead is 25% of the executor memory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--conf spark.executor.extraJavaOptions=-XX:MaxDirectMemorySize=8G</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://medium.com/analytics-vidhya/solving-container-killed-by-yarn-for-exceeding-memory-limits-exception-in-apache-spark-b3349685df16">Solving “Container Killed by Yarn For Exceeding Memory Limits” Exception in Apache Spark</a></p>
<p><a href="https://aws.amazon.com/premiumsupport/knowledge-center/emr-spark-yarn-memory-limit/#:~:text=Memory%20overhead%20is%20the%20amount,libraries%2C%20or%20memory%20mapped%20files.">How do I resolve the error “Container killed by YARN for exceeding memory limits” in Spark on Amazon EMR?</a></p>
<p><a href="https://stackoverflow.com/questions/40781354/container-killed-by-yarn-for-exceeding-memory-limits-10-4-gb-of-10-4-gb-physic">“Container killed by YARN for exceeding memory limits. 10.4 GB of 10.4 GB physical memory used” on an EMR cluster with 75GB of memory</a></p>
<p><a href="https://www.youtube.com/watch?v=t97VJtPAL2s">https://www.youtube.com/watch?v=t97VJtPAL2s</a></p>
<p><a href="https://issues.apache.org/jira/browse/YARN-2225">Turn the virtual memory check to be off by default</a></p>
<p><a href="https://issues.apache.org/jira/browse/YARN-4714">[Java 8] Over usage of virtual memory</a></p>
<p><a href="https://www.xspdf.com/resolution/50926958.html">Yarn memory limit</a></p>
<p><a href="https://stackoverflow.com/questions/37505638/understanding-spark-physical-plan">https://stackoverflow.com/questions/37505638/understanding-spark-physical-plan</a></p>
<p><a href="https://community.hortonworks.com/questions/36266/spark-physical-plan-doubts-tungstenaggregate-tungs.html">https://community.hortonworks.com/questions/36266/spark-physical-plan-doubts-tungstenaggregate-tungs.html</a></p>
<p><a href="https://www.waitingforcode.com/apache-spark/apache-spark-off-heap-memory/read#off-heap_memory_and_Project_Tungsten">Apache Spark and off-heap memory</a></p>
<p><a href="https://medium.com/walmartglobaltech/decoding-memory-in-spark-parameters-that-are-often-confused-c11be7488a24">Decoding Memory in Spark — Parameters that are often confused</a></p>
<p><a href="http://stackoverflow.com/questions/29850784/what-are-the-likely-causes-of-org-apache-spark-shuffle-metadatafetchfailedexcept">http://stackoverflow.com/questions/29850784/what-are-the-likely-causes-of-org-apache-spark-shuffle-metadatafetchfailedexcept</a></p>
<p><a href="http://apache-spark-developers-list.1001551.n3.nabble.com/Lost-executor-on-YARN-ALS-iterations-td7916.html">http://apache-spark-developers-list.1001551.n3.nabble.com/Lost-executor-on-YARN-ALS-iterations-td7916.html</a></p>
<p><a href="https://issues.apache.org/jira/browse/SPARK-4516?focusedCommentId=14220157&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14220157">https://issues.apache.org/jira/browse/SPARK-4516?focusedCommentId=14220157&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14220157</a></p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>issue</tag>
      </tags>
  </entry>
  <entry>
    <title>zepplin中文显示修复</title>
    <url>/2021/08/30/Zeppelin%20%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>当在zeppelin使用livy interpreter，sql查询结果含中文时，显示乱行或结果为空且中文显示为unicode码<span id="more"></span>，如下图所示<br><img src="/images/2435604110871.png"></p>
<h1 id="大数据团队分析过程"><a href="#大数据团队分析过程" class="headerlink" title="大数据团队分析过程"></a>大数据团队分析过程</h1><p>zeppelin从livy拿到的是一个字符串形如：<br><img src="/images/4084004129297.png"><br>zeppelin解析结果字符串源码位置</p>
<p>org.apache.zeppelin.livy.LivySparkSQLInterpreter#parseSQLOutput</p>
<p>主要逻辑如下：</p>
<p>根据spark.show()方法返回的字符串的第一行进行切割得出每列固定长度如上图的第一行+—–+—+<br>所以第一列字符串的长度为5，第二列字符串的长度为3.<br>由于spark.show() 方法为了对齐显示对中文进行了中文字符个数×2的操作，表现在第一行的占位上<br>但zepplin拿到的字符串中文还是占一个char，导致单元格起始和终止位置切割错误。显示乱行。</p>
<p>中文显示为unicode码的原因是因为zepplin对字符进行了转义</p>
<p>于是给社区提问题反馈<br><a href="https://issues.apache.org/jira/browse/ZEPPELIN-5458">https://issues.apache.org/jira/browse/ZEPPELIN-5458</a></p>
<h1 id="bug-修复"><a href="#bug-修复" class="headerlink" title="bug 修复"></a>bug 修复</h1><p>修复思路由于spark.show 中文占两个char, zepplin 又是按一个char数位置<br>所以我们可以直接将每个中文替换成自身加一个特殊字符<br><img src="/images/3295905117164.png"><br>在添加回单元格内容的时候再将特使字符替换成空串<br><img src="/images/5586305137330.png"><br>中文显示unicode码部分则在转义源码部分屏蔽掉中文<br><img src="/images/1266006129999.png"><br>于是给社区提了个pr<br><a href="https://github.com/apache/zeppelin/pull/4179">https://github.com/apache/zeppelin/pull/4179</a></p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>修复后中文可正常显示如下图所示<br><img src="/images/3287206126554.png"></p>
<p>性能测试<br>20万条记录一千万中文解析成table耗时2.117s<br>从时间复杂度上分析，排除掉buffer扩容因素，时间复杂度为o(n)<br><img src="/images/5025806122308.png"></p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>issue</tag>
        <tag>zeppelin</tag>
      </tags>
  </entry>
  <entry>
    <title>spark broadcast join</title>
    <url>/2021/09/16/Spark%E5%B9%BF%E6%92%AD%E6%9D%A1%E4%BB%B6%E5%88%A4%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="spark-sql执行流程"><a href="#spark-sql执行流程" class="headerlink" title="spark sql执行流程"></a>spark sql执行流程</h1><span id="more"></span>
<p><img src="/images/5701401140956.png"><br><font color =red>sql 通过SparkSqlParser利用antrl4进行语法词法解析成未解析的逻辑计划，再通过Analyzer<br>将节点与元数据进行绑定生成已解析的逻辑计划，再通过SparkOptimizer进行逻辑计划的优化<br>如谓词下推等等，最后再通过SparkPlanner生成可执行的物理计划</font></p>
<h1 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h1><p>以下代码是将join的逻辑计划转为物理计划</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- Without joining keys ------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick BroadcastNestedLoopJoin if one side could be broadcast</span></span><br><span class="line"><span class="keyword">case</span> j @ logical.<span class="type">Join</span>(left, right, joinType, condition)</span><br><span class="line">    <span class="keyword">if</span> canBroadcastByHints(joinType, left, right) =&gt;</span><br><span class="line">  <span class="keyword">val</span> buildSide = broadcastSideByHints(joinType, left, right)</span><br><span class="line">  joins.<span class="type">BroadcastNestedLoopJoinExec</span>(</span><br><span class="line">    planLater(left), planLater(right), buildSide, joinType, condition) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> j @ logical.<span class="type">Join</span>(left, right, joinType, condition)</span><br><span class="line">    <span class="keyword">if</span> canBroadcastBySizes(joinType, left, right) =&gt;</span><br><span class="line">  <span class="keyword">val</span> buildSide = broadcastSideBySizes(joinType, left, right)</span><br><span class="line">  joins.<span class="type">BroadcastNestedLoopJoinExec</span>(</span><br><span class="line">    planLater(left), planLater(right), buildSide, joinType, condition) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick CartesianProduct for InnerJoin</span></span><br><span class="line"><span class="keyword">case</span> logical.<span class="type">Join</span>(left, right, _: <span class="type">InnerLike</span>, condition) =&gt;</span><br><span class="line">  joins.<span class="type">CartesianProductExec</span>(planLater(left), planLater(right), condition) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> logical.<span class="type">Join</span>(left, right, joinType, condition) =&gt;</span><br><span class="line">  <span class="keyword">val</span> buildSide = broadcastSide(</span><br><span class="line">    left.stats.hints.broadcast, right.stats.hints.broadcast, left, right)</span><br><span class="line">  <span class="comment">// This join could be very slow or OOM</span></span><br><span class="line">  joins.<span class="type">BroadcastNestedLoopJoinExec</span>(</span><br><span class="line">    planLater(left), planLater(right), buildSide, joinType, condition) :: <span class="type">Nil</span></span><br></pre></td></tr></table></figure>
<p>无关联键值的join都会走到源码的4个case。接下来我们主要分析前两个case</p>
<h1 id="case-1"><a href="#case-1" class="headerlink" title="case 1"></a>case 1</h1><p>用例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ BROADCAST(t1) */</span> t1.a <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> t2</span><br></pre></td></tr></table></figure>
<p>该语法为强制广播左表,t1和t2均为hive表</p>
<p>第一个case主要判断是否可以根据hints广播</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> j @ logical.<span class="type">Join</span>(left, right, joinType, condition)</span><br><span class="line">          <span class="keyword">if</span> canBroadcastByHints(joinType, left, right)</span><br></pre></td></tr></table></figure>
<p>我们再来细看canBroadcastByHints</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> buildLeft = canBuildLeft(joinType) &amp;&amp; left.stats.hints.broadcast</span><br><span class="line"><span class="keyword">val</span> buildRight = canBuildRight(joinType) &amp;&amp; right.stats.hints.broadcast</span><br><span class="line">buildLeft || buildRight</span><br></pre></td></tr></table></figure>
<p>首先看的第一个条件是可以广播左表还是右表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">canBuildRight</span></span>(joinType: <span class="type">JoinType</span>): <span class="type">Boolean</span> = joinType <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">InnerLike</span> | <span class="type">LeftOuter</span> | <span class="type">LeftSemi</span> | <span class="type">LeftAnti</span> | _: <span class="type">ExistenceJoin</span> =&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">canBuildLeft</span></span>(joinType: <span class="type">JoinType</span>): <span class="type">Boolean</span> = joinType <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">InnerLike</span> | <span class="type">RightOuter</span> =&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果为左连或内连可以广播右表</li>
<li>如果为右连或者内联则可以广播左表<br><font color =red>总结：left join 只能广播右表，right join只能广播左表，inner join 左右表均可</font></li>
</ul>
<p>广播必须满足的第二个条件为left.stats.hints.broadcast是否为true<br>left.stats 源码</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats</span></span>: <span class="type">Statistics</span> = statsCache.getOrElse &#123;</span><br><span class="line">   <span class="keyword">if</span> (conf.cboEnabled) &#123;</span><br><span class="line">     statsCache = <span class="type">Option</span>(<span class="type">BasicStatsPlanVisitor</span>.visit(self))</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     statsCache = <span class="type">Option</span>(<span class="type">SizeInBytesOnlyStatsPlanVisitor</span>.visit(self))</span><br><span class="line">   &#125;</span><br><span class="line">   statsCache.get</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>由于cboEnabled默认为false，暂不讨论为true的情况看，接下来我们再看<br>SizeInBytesOnlyStatsPlanVisitor.visit(logicalplan)<br>此处的逻辑计划为下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ResolvedHint (broadcast)</span><br><span class="line">+- Project [a#44]</span><br><span class="line">   +- HiveTableRelation `default`.`t1`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [a#44, b#45]</span><br></pre></td></tr></table></figure>
<p>所以case到这条语句<br>case p: ResolvedHint =&gt; visitHint(p)<br>跳到下列执行语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override def visitHint(p: ResolvedHint): Statistics = p.child.stats.copy(hints = p.hints)</span><br></pre></td></tr></table></figure>
<p>当前节点ResolvedHint的hints.broadcast为true拷贝给子节点的统计信息导致left.stats.hints.broadcast为true<br>所以case1的两个条件均命中可广播左表最终生成的物理计划为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BroadcastNestedLoopJoin BuildLeft, Inner</span><br><span class="line">:- BroadcastExchange IdentityBroadcastMode</span><br><span class="line">:  +- Scan hive default.t1 [a#50], HiveTableRelation `default`.`t1`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [a#50, b#51]</span><br><span class="line">+- Scan hive default.t2 HiveTableRelation `default`.`t2`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [a#52, c#53]</span><br></pre></td></tr></table></figure>
<p>补充 另一种强制广播方式为通过broadcast函数广播dataframe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def broadcast[T](df: Dataset[T]): Dataset[T] = &#123;</span><br><span class="line">Dataset[T](df.sparkSession,</span><br><span class="line">    ResolvedHint(df.logicalPlan, HintInfo(broadcast = true)))(df.exprEnc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数作用相当于在当前逻辑计划上包一层ResolvedHint逻辑计划且把broadcast设为true<br>函数和sql强制广播方式物理计划生成的过程是一样的。</p>
<h1 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h1><p>用例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT t1.a FROM t1 JOIN t2</span><br></pre></td></tr></table></figure>
<p>第二个case根据size判断是否满足广播</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> j @ logical.<span class="type">Join</span>(left, right, joinType, condition)</span><br><span class="line">          <span class="keyword">if</span> canBroadcastBySizes(joinType, left, right)</span><br></pre></td></tr></table></figure>

<p>canBroadcastBySizes函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> buildLeft = canBuildLeft(joinType) &amp;&amp; canBroadcast(left)</span><br><span class="line"><span class="keyword">val</span> buildRight = canBuildRight(joinType) &amp;&amp; canBroadcast(right)</span><br><span class="line">broadcastSide(buildLeft, buildRight, left, right)</span><br></pre></td></tr></table></figure>
<p>由于连接类型为inner 所以canBuildLeft、canBuildRight均为true<br>broadcastSide函数作用为如果两张表大小都满足条件则广播最小的表<br>canBroadcast 函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">canBroadcast</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    plan.stats.sizeInBytes &gt;= <span class="number">0</span> &amp;&amp; plan.stats.sizeInBytes &lt;= conf.autoBroadcastJoinThreshold</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数是将当前节点的逻辑计划size和广播阈值作比较判断是否适合广播<br>plan.stats.sizeInBytes<br>left.stats 源码</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats</span></span>: <span class="type">Statistics</span> = statsCache.getOrElse &#123;</span><br><span class="line">   <span class="keyword">if</span> (conf.cboEnabled) &#123;</span><br><span class="line">     statsCache = <span class="type">Option</span>(<span class="type">BasicStatsPlanVisitor</span>.visit(self))</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     statsCache = <span class="type">Option</span>(<span class="type">SizeInBytesOnlyStatsPlanVisitor</span>.visit(self))</span><br><span class="line">   &#125;</span><br><span class="line">   statsCache.get</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>SizeInBytesOnlyStatsPlanVisitor.visit(logicalplan)<br>当前左表的逻辑计划为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Project [a#44]</span><br><span class="line">+- HiveTableRelation `default`.`t1`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [a#44, b#45]</span><br></pre></td></tr></table></figure>
<p>根据当前逻辑计划case到visitProject(p)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">visitUnaryNode</span></span>(p: <span class="type">UnaryNode</span>): <span class="type">Statistics</span> = &#123;</span><br><span class="line"><span class="comment">// There should be some overhead in Row object, the size should not be zero when there is</span></span><br><span class="line"><span class="comment">// no columns, this help to prevent divide-by-zero error.</span></span><br><span class="line"><span class="keyword">val</span> childRowSize = <span class="type">EstimationUtils</span>.getSizePerRow(p.child.output)</span><br><span class="line"><span class="keyword">val</span> outputRowSize = <span class="type">EstimationUtils</span>.getSizePerRow(p.output)</span><br><span class="line"><span class="comment">// Assume there will be the same number of rows as child has.</span></span><br><span class="line"><span class="keyword">var</span> sizeInBytes = (p.child.stats.sizeInBytes * outputRowSize) / childRowSize</span><br><span class="line"><span class="keyword">if</span> (sizeInBytes == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// sizeInBytes can&#x27;t be zero, or sizeInBytes of BinaryNode will also be zero</span></span><br><span class="line">    <span class="comment">// (product of children).</span></span><br><span class="line">    sizeInBytes = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t propagate rowCount and attributeStats, since they are not estimated here.</span></span><br><span class="line"><span class="type">Statistics</span>(sizeInBytes = sizeInBytes, hints = p.child.stats.hints)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处逻辑为首先看子节点逻辑计划输出的列属性来估算每行的size大小（即t1表的所有字段属性的累加）<br>outputRowSize为列裁剪后的字段属性估值，此处为t1.a<br>p.child.stats.sizeInBytes 为t1 hive表的大小。所以当前逻辑计划的总大小估值公式为：<br><strong>输出字段(t1.a)属性的size和/hive表全字段属性size的和*hive表大小</strong><br>属性size估值函数 EstimationUtils.getSizePerRow</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    attr.dataType.defaultSize</span><br><span class="line">&#125;.sum</span><br></pre></td></tr></table></figure>
<p>接下来我们再深入探讨一下p.child.stats.sizeInBytes即hive表的size是如何获取到的<br>依然走到这个函数SizeInBytesOnlyStatsPlanVisitor.visit(logicalplan)<br>case 到 default(p)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">default</span></span>(p: <span class="type">LogicalPlan</span>): <span class="type">Statistics</span> = p <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> p: <span class="type">LeafNode</span> =&gt; p.computeStats()</span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">LogicalPlan</span> =&gt; <span class="type">Statistics</span>(sizeInBytes = p.children.map(_.stats.sizeInBytes).product)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处p为叶子节点HiveTableRelation所以跳转到以下函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override def computeStats(): Statistics = &#123;</span><br><span class="line">  tableMeta.stats.map(_.toPlanStats(output, conf.cboEnabled)).getOrElse &#123;</span><br><span class="line">    throw new IllegalStateException(&quot;table stats must be specified.&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终获取元数据CatalogTable.CatalogStatistics.sizeInBytes 封装成Statistics(sizeInBytes = sizeInBytes)返回<br>换句话说hive表size大小源头是封装在catalogtable中，那是什么时候获取到的呢<br>其实是在Analyzer中生成的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def resolveRelation(plan: LogicalPlan): LogicalPlan = plan match &#123;</span><br><span class="line">     case u: UnresolvedRelation if !isRunningDirectlyOnFiles(u.tableIdentifier) =&gt;</span><br><span class="line">       val defaultDatabase = AnalysisContext.get.defaultDatabase</span><br><span class="line">       val foundRelation = lookupTableFromCatalog(u, defaultDatabase)</span><br><span class="line">       resolveRelation(foundRelation)</span><br></pre></td></tr></table></figure>
<p>org.apache.spark.sql.hive.HiveExternalCatalog#getRawTable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private[hive] def getRawTable(db: String, table: String): CatalogTable = &#123;</span><br><span class="line">  client.getTable(db, table)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.apache.spark.sql.hive.client.HiveClientImpl#getTableOption</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getTableOption</span></span>(</span><br><span class="line">     dbName: <span class="type">String</span>,</span><br><span class="line">     tableName: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">CatalogTable</span>] = withHiveState &#123;</span><br><span class="line">   getRawTableOption(dbName, tableName).map &#123; h =&gt;</span><br><span class="line">     <span class="type">CatalogTable</span>(</span><br><span class="line">       identifier = <span class="type">TableIdentifier</span>(h.getTableName, <span class="type">Option</span>(h.getDbName)),</span><br><span class="line">       tableType = h.getTableType <span class="keyword">match</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="type">HiveTableType</span>.<span class="type">EXTERNAL_TABLE</span> =&gt; <span class="type">CatalogTableType</span>.<span class="type">EXTERNAL</span></span><br><span class="line">         <span class="keyword">case</span> <span class="type">HiveTableType</span>.<span class="type">MANAGED_TABLE</span> =&gt; <span class="type">CatalogTableType</span>.<span class="type">MANAGED</span></span><br><span class="line">         <span class="keyword">case</span> <span class="type">HiveTableType</span>.<span class="type">VIRTUAL_VIEW</span> =&gt; <span class="type">CatalogTableType</span>.<span class="type">VIEW</span></span><br><span class="line">         <span class="keyword">case</span> <span class="type">HiveTableType</span>.<span class="type">INDEX_TABLE</span> =&gt;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AnalysisException</span>(<span class="string">&quot;Hive index table is not supported.&quot;</span>)</span><br><span class="line">       &#125;,</span><br><span class="line">       schema = schema,</span><br><span class="line">       partitionColumnNames = partCols.map(_.name),</span><br><span class="line">       <span class="comment">// If the table is written by Spark, we will put bucketing information in table properties,</span></span><br><span class="line">       <span class="comment">// and will always overwrite the bucket spec in hive metastore by the bucketing information</span></span><br><span class="line">       <span class="comment">// in table properties. This means, if we have bucket spec in both hive metastore and</span></span><br><span class="line">       <span class="comment">// table properties, we will trust the one in table properties.</span></span><br><span class="line">       bucketSpec = bucketSpec,</span><br><span class="line">       owner = <span class="type">Option</span>(h.getOwner).getOrElse(<span class="string">&quot;&quot;</span>),</span><br><span class="line">       createTime = h.getTTable.getCreateTime.toLong * <span class="number">1000</span>,</span><br><span class="line">       lastAccessTime = h.getLastAccessTime.toLong * <span class="number">1000</span>,</span><br><span class="line">       storage = <span class="type">CatalogStorageFormat</span>(</span><br><span class="line">         locationUri = shim.getDataLocation(h).map(<span class="type">CatalogUtils</span>.stringToURI),</span><br><span class="line">         <span class="comment">// To avoid ClassNotFound exception, we try our best to not get the format class, but get</span></span><br><span class="line">         <span class="comment">// the class name directly. However, for non-native tables, there is no interface to get</span></span><br><span class="line">         <span class="comment">// the format class name, so we may still throw ClassNotFound in this case.</span></span><br><span class="line">         inputFormat = <span class="type">Option</span>(h.getTTable.getSd.getInputFormat).orElse &#123;</span><br><span class="line">           <span class="type">Option</span>(h.getStorageHandler).map(_.getInputFormatClass.getName)</span><br><span class="line">         &#125;,</span><br><span class="line">         outputFormat = <span class="type">Option</span>(h.getTTable.getSd.getOutputFormat).orElse &#123;</span><br><span class="line">           <span class="type">Option</span>(h.getStorageHandler).map(_.getOutputFormatClass.getName)</span><br><span class="line">         &#125;,</span><br><span class="line">         serde = <span class="type">Option</span>(h.getSerializationLib),</span><br><span class="line">         compressed = h.getTTable.getSd.isCompressed,</span><br><span class="line">         properties = <span class="type">Option</span>(h.getTTable.getSd.getSerdeInfo.getParameters)</span><br><span class="line">           .map(_.asScala.toMap).orNull</span><br><span class="line">       ),</span><br><span class="line">       <span class="comment">// For EXTERNAL_TABLE, the table properties has a particular field &quot;EXTERNAL&quot;. This is added</span></span><br><span class="line">       <span class="comment">// in the function toHiveTable.</span></span><br><span class="line">       properties = filteredProperties,</span><br><span class="line">       stats = readHiveStats(properties),</span><br><span class="line">       comment = comment,</span><br><span class="line">       <span class="comment">// In older versions of Spark(before 2.2.0), we expand the view original text and store</span></span><br><span class="line">       <span class="comment">// that into `viewExpandedText`, and that should be used in view resolution. So we get</span></span><br><span class="line">       <span class="comment">// `viewExpandedText` instead of `viewOriginalText` for viewText here.</span></span><br><span class="line">       viewText = <span class="type">Option</span>(h.getViewExpandedText),</span><br><span class="line">       unsupportedFeatures = unsupportedFeatures,</span><br><span class="line">       ignoredProperties = ignoredProperties.toMap)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>properties 通过HiveMetaStoreClient获取到hive表的各项元数据形如<br><img src="/images/3869937199382.png"></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">readHiveStats</span></span>(properties: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">Option</span>[<span class="type">CatalogStatistics</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> totalSize = properties.get(<span class="type">StatsSetupConst</span>.<span class="type">TOTAL_SIZE</span>).map(<span class="type">BigInt</span>(_))</span><br><span class="line">  <span class="keyword">val</span> rawDataSize = properties.get(<span class="type">StatsSetupConst</span>.<span class="type">RAW_DATA_SIZE</span>).map(<span class="type">BigInt</span>(_))</span><br><span class="line">  <span class="keyword">val</span> rowCount = properties.get(<span class="type">StatsSetupConst</span>.<span class="type">ROW_COUNT</span>).map(<span class="type">BigInt</span>(_))</span><br><span class="line">  <span class="keyword">if</span> (totalSize.isDefined &amp;&amp; totalSize.get &gt; <span class="number">0</span>L) &#123;</span><br><span class="line">    <span class="type">Some</span>(<span class="type">CatalogStatistics</span>(sizeInBytes = totalSize.get, rowCount = rowCount.filter(_ &gt; <span class="number">0</span>)))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawDataSize.isDefined &amp;&amp; rawDataSize.get &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Some</span>(<span class="type">CatalogStatistics</span>(sizeInBytes = rawDataSize.get, rowCount = rowCount.filter(_ &gt; <span class="number">0</span>)))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> still fill the rowCount even if sizeInBytes is empty. Might break anything?</span></span><br><span class="line">    <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将获取到的元数据properties中的totalSize封装回CatalogStatistics</p>
<h1 id="msql表"><a href="#msql表" class="headerlink" title="msql表"></a>msql表</h1><p>用例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.a <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> t2</span><br></pre></td></tr></table></figure>
<p>将t1，t2换成mysql表继续分析<br>从上文分析我们可以得知，根据size广播的源头为表的大小，下图为spark所有的叶子节点（即表）类图<br><img src="/images/5966146090957.png"><br>当我们表为mysql表时，叶子节点为LogicalRelation</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">computeStats</span></span>(): <span class="type">Statistics</span> = &#123;</span><br><span class="line">   catalogTable</span><br><span class="line">     .flatMap(_.stats.map(_.toPlanStats(output, conf.cboEnabled)))</span><br><span class="line">     .getOrElse(<span class="type">Statistics</span>(sizeInBytes = relation.sizeInBytes))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>最后调到relation.sizeInBytes即<br>def sizeInBytes: Long = sqlContext.conf.defaultSizeInBytes<br>默认值为下列配置<br>spark.sql.defaultSizeInBytes（默认值Long.MaxValue）<br>不是hive表时，表大小为long的最大值</p>
<p>还有一个疑问是上面的relation具体又是什么呢，接下来我们细看<br>mysql用例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spark.sqlContext.read.format(&quot;jdbc&quot;)</span><br><span class="line">  .option(&quot;url&quot;, Constants.JDBC_URL)</span><br><span class="line">  .option(&quot;driver&quot;, &quot;com.mysql.jdbc.Driver&quot;)</span><br><span class="line">  .option(&quot;dbtable&quot;, &quot;t_data_product_vmodels&quot;)</span><br><span class="line">  .option(&quot;user&quot;, Constants.JDBC_USER)</span><br><span class="line">  .option(&quot;password&quot;, Constants.JDBC_PASSWORD)</span><br><span class="line">  .load().createOrReplaceTempView(&quot;t1&quot;)</span><br></pre></td></tr></table></figure>
<p>load函数核心操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sparkSession.baseRelationToDataFrame(</span><br><span class="line">  DataSource.apply(</span><br><span class="line">    sparkSession,</span><br><span class="line">    paths = paths,</span><br><span class="line">    userSpecifiedSchema = userSpecifiedSchema,</span><br><span class="line">    className = source,</span><br><span class="line">    options = extraOptions.toMap).resolveRelation())</span><br></pre></td></tr></table></figure>
<p>上文中的relation就是这里创建的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def resolveRelation(checkFilesExist: Boolean = true): BaseRelation = &#123;</span><br><span class="line">   val relation = (providingClass.newInstance(), userSpecifiedSchema) match &#123;</span><br><span class="line">     case (dataSource: RelationProvider, Some(schema)) =&gt;</span><br><span class="line">       val baseRelation =</span><br><span class="line">         dataSource.createRelation(sparkSession.sqlContext, caseInsensitiveOptions)</span><br><span class="line">       baseRelation</span><br></pre></td></tr></table></figure>
<p>首先根据format的短名jdbc找到jdbcdatasourceprovider然后再通过dataSource.createRelation创建出JDBCrelation<br>provider的class寻找逻辑是通过DataSource.lookupDataSource完成的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val serviceLoader = ServiceLoader.load(classOf[DataSourceRegister], loader)</span><br><span class="line">serviceLoader.asScala.filter(_.shortName().equalsIgnoreCase(provider1)).toList</span><br></pre></td></tr></table></figure>
<p><img src="/images/2511453149383.png"><br>最后生成JDBCrelation</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override def createRelation(</span><br><span class="line">    sqlContext: SQLContext,</span><br><span class="line">    parameters: Map[String, String]): BaseRelation = &#123;</span><br><span class="line">  val jdbcOptions = new JDBCOptions(parameters)</span><br><span class="line">  val resolver = sqlContext.conf.resolver</span><br><span class="line">  val timeZoneId = sqlContext.conf.sessionLocalTimeZone</span><br><span class="line">  val schema = JDBCRelation.getSchema(resolver, jdbcOptions)</span><br><span class="line">  val parts = JDBCRelation.columnPartition(schema, resolver, timeZoneId, jdbcOptions)</span><br><span class="line">  JDBCRelation(schema, parts, jdbcOptions)(sqlContext.sparkSession)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注JDBCRelation默认分区为1</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>强制广播优先级大于根据size广播优先级。broadcast join 运行效率远大于Sort Merge Join<br>若为hive表且spark可获取到hive的元数据信息，建议增大spark.sql.autoBroadcastJoinThreshold阈值进行广播join</p>
<p>若为spark无法获取到元数据信息的表，则使用以下语法强制广播，但必须保证此表不是大数据量否则容易暴内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT /*+ BROADCAST(t1) */ t1.a FROM t1 JOIN t2</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>docker命令</title>
    <url>/2021/09/16/docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="查看所有正在运行的容器"><a href="#查看所有正在运行的容器" class="headerlink" title="查看所有正在运行的容器"></a>查看所有正在运行的容器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<span id="more"></span> 
<h1 id="根据容器ID-stop"><a href="#根据容器ID-stop" class="headerlink" title="根据容器ID stop"></a>根据容器ID stop</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop containerId</span><br></pre></td></tr></table></figure>
<h1 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<h1 id="查看所有容器id"><a href="#查看所有容器id" class="headerlink" title="查看所有容器id"></a>查看所有容器id</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -a -q</span><br></pre></td></tr></table></figure>
<h1 id="停止所有容器"><a href="#停止所有容器" class="headerlink" title="停止所有容器"></a>停止所有容器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<h1 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker  rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<h1 id="查看指定容器的日志"><a href="#查看指定容器的日志" class="headerlink" title="查看指定容器的日志"></a>查看指定容器的日志</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs CONTAINER</span><br></pre></td></tr></table></figure>
<h1 id="进入container交互式窗口命令"><a href="#进入container交互式窗口命令" class="headerlink" title="进入container交互式窗口命令"></a>进入container交互式窗口命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it CONTAINER  bash</span><br></pre></td></tr></table></figure>
<h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure>
<h1 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>
<h1 id="查看所有镜像"><a href="#查看所有镜像" class="headerlink" title="查看所有镜像"></a>查看所有镜像</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h1 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search &lt;IMAGE_ID/NAME&gt;</span><br></pre></td></tr></table></figure>
<h1 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull  &lt;IMAGE_ID&gt;</span><br></pre></td></tr></table></figure>
<h1 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi &lt;IMAGE_ID&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
